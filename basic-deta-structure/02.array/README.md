# Array

### 配列の仕組み
- 同じデータ型となる要素を集めたもの
- 要素を指定するための通し番号は添字(index)

### Pythonと配列
- Pythonのリスト (List)
  - 一般的な言語における配列とほぼ同じものとする文献が多い
  - CPythonなどの実装では可変長配列

- Pythonの配列 (array)
  - arrayモジュールをimportして使用
  - 全ての要素が同じ型
  - リストと比較して、高速でメモリー節約できる

- NumPyのn次元配列 (ndarray)
  - 外部のパッケージ (https://numpy.org/)
  - ベクトルや行列などの数値演算

### 配列のデータ挿入
配列の中にすでに6つの要素がある場合、先頭に新しく値を挿入したい
その場合、配列の中にある既存の値の位置をずらす必要がある
(データの移動が必要)
n個のデータを移動させないと挿入できない

これがかなり負荷がかかり、効率が悪い

### 配列のデータ削除
配列にすでに7このデータがある
先頭のデータを削除したら、添字0のデータがなくなる
その場合、添字1以降のデータを前に移動する必要がある

(データの移動が必要)

n個のデータを移動させないと削除できない

これがかなり負荷がかかり、効率が悪い

### 配列へのデータ挿入と削除

- 配列のデータの挿入と削除は位置によっては、負荷の大きい操作になる
  - 不連続の空きを作らない場合

これを解決できるのが、連結リスト

## データの探索

- 線形探索 (linear search)
  - 配列の先頭から順番に探索する方法
    - O(n)の計算量

- 二分探索 (binary search)
  - 配列がソートされている場合に使用する
    - O(log n)の計算量

#### 線形探索

- 配列の先頭から順に比較し、探索キーのデータを探す
  - 800の値を探す際に、index 0から順に探す

- n個のデータがある場合の探索に必要な比較回数
  - 最良: 1回
  - 最悪: n回
  - 平均: (n+1)/2 回


#### 二分探索

- 整列済みの配列に対して探索を行う
- 配列中央の値と探索キーの値を比較し、探索キーの値との大小関係を基に探索を進める

- データ800を探索する場合
- 配列の中央の値を取得し、探索キーの値と比較
  - 800 > 500
  - 800 < 900
  - 800 > 700
  - 800 < 800

- どんどん探索範囲を狭めていく

- n個のデータがある場合の探索に必要な比較回数
  - 最悪: log2(n)回

#### 線形探索と二分探索 比較回数

- 1,000,000件のデータを探索した際の平均の比較数
  - 線形探索: 500,000回 (最悪n回)
  - 二分探索: 20回 (最悪log2(n)回)

- 圧倒的に二分探索の方が効率がいい

- 探索回数が多くなると、高速なCPUを使用しても線形探索は遅い
- 二分探索は、データが多くても高速に探索できる
  - しかし、データが事前に整列されている必要がある
  - また、データの挿入や削除が発生する場合は、整列を維持する必要がある

### 計算量

- 特定の手順によって問題に解くときに必要となる時間は、計算量、または時間計算量、時間複雑性と呼ばれる
- コンピューターによって実行速度は異なる

- そこで、計算量は問題を解くのに必要な手順のステップ数を基に算出される

#### ビック・オー記法

- Big O Notation (ビッグ・オー・ノーテーション)
  - "O"はオーダー(Order)の意味
  - データ数と実行時間の関係を表現
  - アルゴリズムの速度を比較する

- 例 データを探索する平均の計算量
  - 線形探索: O(n)
  - 二分探索: O(log n)



